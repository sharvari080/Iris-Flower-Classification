# -*- coding: utf-8 -*-
"""Unemployment Analysis with Python

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZeT4g54PM6jilerQr3cAgOlMBduqvNTI
"""

#importing the necessary libraries
import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import seaborn as sns

import calendar

import datetime as dt

import plotly.io as pio
import plotly.express as px
import plotly.graph_objects as go
import plotly.figure_factory as ff
from IPython.display import HTML

data = pd.read_csv('/content/Unemployment in India.csv')

#displaying the dataframe
data.head()

data.shape

data.info

data.isnull().sum()

# Check the current column names and count
print(data.columns)

# Update column names to match the number of columns in the dataset
# Adjust the list below to match the exact number of columns
data.columns = ['States', 'Date', 'Frequency', 'Estimated Unemployment Rate', 'Estimated Employed', 'Estimated Labour Participation Rate', 'Region']

data['Date'] = pd.to_datetime(data['Date'],dayfirst=True)

data['Frequency']= data['Frequency'].astype('category')

data['Month'] =  data['Date'].dt.month

data['MonthNumber'] = data['Month'].fillna(0).apply(lambda x: int(x))

data['MonthName'] =  data['MonthNumber'].apply(lambda x: calendar.month_abbr[x])

data['Region'] = data['Region'].astype('category')

data.drop(columns='Month',inplace=True)
data.head(3)

#5-number summary
data.describe()

round(data[['Estimated Unemployment Rate', 'Estimated Employed', 'Estimated Labour Participation Rate']].describe().T,2)

#grouping by 'Region' and finding mean values for the numerical columns
regionStats = data.groupby(['Region'])[['Estimated Unemployment Rate',
                                      'Estimated Employed',
                                      'Estimated Labour Participation Rate']].mean().reset_index()

#rounding the values to 2 decimal points
round(regionStats,2)

# Constructing a dataframe of all available numerical columns for correlation
heatMap = data[['Estimated Unemployment Rate', 'Estimated Employed',
                'Estimated Labour Participation Rate', 'MonthNumber']]

# Calculating pair-wise correlation values
heatMap = heatMap.corr()

# Plotting the heatmap
plt.figure(figsize=(23, 8))
sns.heatmap(heatMap, annot=True, cmap='twilight_shifted', fmt='.3f', linewidths=1)
plt.title('Heatmap of Correlations')
plt.show()

#plotting a box-plot to show un-employment rate in each state
fig = px.box(
    data,
    x='States',
    y='Estimated Unemployment Rate',
    color='States',
    title='unemploymentRate',
    template='plotly'
)
fig.show()

#creating a scatter matrix plot to denote relationship
fig = px.scatter_matrix(data,
    dimensions=['Estimated Unemployment Rate','Estimated Employed',
                'Estimated Labour Participation Rate'],
    color='Region')
fig.show()

#plotting a "Bar-plot" to find the "average unemployment rate in each state"
newDF = data[['Estimated Unemployment Rate','States']]

#grouping the dataframe by 'States' and finding the corresponding 'mean'
newDF = newDF.groupby('States').mean().reset_index()

#sorting the values in the dataframe
newDF = newDF.sort_values('Estimated Unemployment Rate')

fig = px.bar(newDF,
             x='States',
             y='Estimated Unemployment Rate',
             color='States',
             title='State-wise Average Employment Rate')
fig.show()

fig = px.bar(data,
             x='Region',
             y='Estimated Unemployment Rate',
             animation_frame = 'MonthName',
             color='States',
             title='Region-wise Unemployment Rate',
             height=800)

fig.layout.updatemenus[0].buttons[0].args[1]["frame"]["duration"] = 1500

fig.show()

# Creating a new dataframe with 'State-wise' & 'Region-wise' Estimated Unemployment Rate
unempDF = data[['States', 'Region', 'Estimated Unemployment Rate', 'Estimated Employed', 'Estimated Labour Participation Rate']]

# Grouping by 'Region' and 'States' and calculating the mean of 'Estimated Unemployment Rate'
unempDF = unempDF.groupby(['Region', 'States'])['Estimated Unemployment Rate'].mean().reset_index()

# Printing the new dataframe
unempDF.head(4)

#a sunburst chart (hierarchical chart) for unemployment rate region-wise and state-wise
fig = px.sunburst(unempDF,
                  path=['Region','States'],
                  values='Estimated Unemployment Rate',
                  title= 'unemployment rate in each region and state',
                  height=650)
fig.show()

# Adding example longitude and latitude data (replace with actual values)
state_coordinates = {
    'State1': {'longitude': 77.0, 'latitude': 28.7},
    'State2': {'longitude': 72.8, 'latitude': 19.0},
    # Add more states and their respective coordinates
}

# Map coordinates to the data
data['longitude'] = data['States'].map(lambda state: state_coordinates[state]['longitude'] if state in state_coordinates else None)
data['latitude'] = data['States'].map(lambda state: state_coordinates[state]['latitude'] if state in state_coordinates else None)

# Now, creating the scatter geospatial plot
fig = px.scatter_geo(data, 'longitude', 'latitude',
                     color="Region",
                     hover_name="States",
                     size="Estimated Unemployment Rate",
                     animation_frame="MonthName",
                     scope='asia',
                     title='Lockdown Impact throughout India')

fig.layout.updatemenus[0].buttons[0].args[1]["frame"]["duration"] = 1200

# Updating geospatial axes ranges and ocean color
fig.update_geos(lataxis_range=[5, 35],
                lonaxis_range=[65, 100],
                oceancolor="#6dd5ed",
                showocean=True)

fig.show()

# Filtering dataset between months 4 and 7 (inclusive) - after lockdown
df47 = data[(data['MonthNumber'] >= 4) & (data['MonthNumber'] <= 7)]

# Filtering dataset between months 1 and 4 (inclusive) - before lockdown
df14 = data[(data['MonthNumber'] >= 1) & (data['MonthNumber'] <= 4)]

#grouping the dataframe on the basis of "States" and finding the corresponding mean values
df47g = df47.groupby('States')['Estimated Unemployment Rate'].mean().reset_index()

#grouping the dataframe on the basis of "States" and finding the corresponding mean values
df14g = df14.groupby('States')['Estimated Unemployment Rate'].mean().reset_index()

#clubbing the 2 dataframe values
df47g['Unemployment Rate before lockdown'] = df14g['Estimated Unemployment Rate']

#renaming the column values for better understanding
df47g.columns = ['States','unemploymentRate A/ lockdown','unemploymentRate B/ lockdown']

#displaying the top results
df47g.head()

#computing the % change in unemployment rate
df47g['% change in unemployment'] = round(df47g['unemploymentRate A/ lockdown'] - df47g['unemploymentRate B/ lockdown']/df47g['unemploymentRate B/ lockdown'],2)

#sorting the values in the "after lockdown dataframe" on the basis of "%change in unemployment"
df47g = df47g.sort_values('% change in unemployment')

#plotting a 'bar-chart' for the "%change in unemployment A/ lockdown"
fig = px.bar(df47g, x='States',y='% change in unemployment',
             color='% change in unemployment',
             title='% change in Unemployment A/ Lockdown')

fig.show()

#defining a function to sort the values based on impact
#from the above 'box-plot', the values are ranging between 0 and 40

def sort_impact(x):
    if x <= 10:
        #impactedState
        return 'ğŸ¥²'

    elif x <= 20:
        #hardImpactedState
        return 'ğŸ¥²ğŸ˜¥'

    elif x <= 30:
        #harderImpactedState
        return 'ğŸ¥²ğŸ˜¥ğŸ˜–'

    elif x <= 40:
        #hardestImpactedState
        return 'ğŸ¥²ğŸ˜¥ğŸ˜–ğŸ¤¯'

    return x

df47g['impactStatus'] = df47g['% change in unemployment'].apply(lambda x:sort_impact(x))

fig = px.bar(df47g,
             y='States',
             x='% change in unemployment',
             color='impactStatus',
             title='Lockdown Impact on Employment in India')

fig.show()